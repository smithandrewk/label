from app.exceptions import DatabaseError
from app.repositories.project_repository import ProjectRepository
from app.repositories.participant_repository import ParticipantRepository
from app.repositories.session_repository import SessionRepository
from app.logging_config import get_logger
import os
import shutil
from datetime import datetime

# Get logger for this module
logger = get_logger(__name__)

class ProjectService:
    def __init__(self, project_repository=None, session_repository=None, participant_repository=None):
        self.project_repo: ProjectRepository = project_repository
        self.participant_repo: ParticipantRepository = participant_repository
        self.session_repo: SessionRepository = session_repository
    
    def list_projects(self):
        """Get all projects"""
        return self.project_repo.get_all()
    
    def get_participant_by_code(self, participant_code):
        """Find participant by code"""
        return self.participant_repo.find_by_code(participant_code)

    def insert_project(self, project_name, participant_id, path):
        """Create a new project"""
        return self.project_repo.create(project_name, participant_id, path)

    def create_participant(self, participant_code):
        """Create a new participant, handling race conditions if it already exists"""
        return self.participant_repo.create(participant_code)

    def create_participant_with_details(self, participant_code, first_name, last_name, email, notes):
        """Create a new participant with detailed information"""
        result = self.participant_repo.create_with_details(participant_code, first_name, last_name, email, notes)
        print(result)
        return {
            'participant_id': result['participant_id'],
            'participant_code': result['participant_code']
        }

    def get_project_with_participant(self, project_id):
        """Get detailed project information including participant data"""
        return self.project_repo.find_with_participant(project_id)

    def cleanup_participant_if_needed(self, participant_id):
        """Check if participant has any remaining projects and delete if none exist"""
        remaining_projects = self.participant_repo.count_projects(participant_id)
        if remaining_projects == 0:
            self.participant_repo.delete(participant_id)
            return True
        return False

    def delete_project(self, project_id):
        """Delete a project"""
        return self.project_repo.delete(project_id)

    def rename_project(self, project_id, new_name):
        """Rename a project"""
        if not new_name or not new_name.strip():
            raise DatabaseError('Project name cannot be empty')
        
        # Trim whitespace from the new name
        new_name = new_name.strip()
        
        # Update the project name in the database
        return self.project_repo.update_name(project_id, new_name)

    def get_all_participants_with_stats(self):
        """Get all participants with their project and session statistics"""
        return self.participant_repo.get_all_with_stats()

    def update_participant(self, participant_id, participant_code, first_name, last_name, email, notes):
        """Update an existing participant's information"""
        result = self.participant_repo.update(participant_id, participant_code, first_name, last_name, email, notes)
        return {
            'participant_id': result['participant_id'],
            'participant_code': result['participant_code']
        }

    def get_participant_info(self, participant_id):
        """Get basic participant information"""
        return self.participant_repo.find_by_id(participant_id)

    def get_participant_projects(self, participant_id):
        """Get all projects for a participant"""
        return self.project_repo.find_by_participant(participant_id)

    def count_participant_sessions(self, participant_id):
        """Count total sessions for a participant across all their projects"""
        return self.participant_repo.count_sessions(participant_id)

    def delete_participant_cascade(self, participant_id):
        """Delete participant and all associated data (projects, sessions, lineage)"""
        return self.participant_repo.delete_cascade(participant_id)

    def create_project_with_files(self, project_name, participant_code, uploaded_files, data_dir):
        """
        Create a new project with uploaded files, handling participant creation and file storage
        
        Args:
            project_name: Name of the project
            participant_code: Code for the participant
            uploaded_files: List of uploaded file objects
            data_dir: Base directory for storing project data
            
        Returns:
            dict: Project creation result with project_id, participant_id, and project_path
        """
        # Get or create participant
        participant = self.get_participant_by_code(participant_code)
        if participant:
            participant_id = participant['participant_id']
        else:
            created_participant = self.create_participant(participant_code)
            participant_id = created_participant['participant_id']

        # Create project directory
        central_data_dir = os.path.expanduser(data_dir)
        os.makedirs(central_data_dir, exist_ok=True)
        
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        project_dir_name = f"{project_name}_{participant_code}_{timestamp}"
        new_project_path = os.path.join(central_data_dir, project_dir_name)
        
        try:
            # Create project directory and save files
            os.makedirs(new_project_path, exist_ok=True)
            
            # Process uploaded files and recreate directory structure
            for file in uploaded_files:
                if file.filename and file.filename != '':
                    # Get relative path within the selected folder
                    relative_path = file.filename
                    if '/' in relative_path:
                        # Remove the root folder name from the path since we're creating our own structure
                        path_parts = relative_path.split('/')
                        if len(path_parts) > 1:
                            relative_path = '/'.join(path_parts[1:])  # Remove the first part (root folder name)
                    
                    # Create full file path
                    file_path = os.path.join(new_project_path, relative_path)
                    
                    # Create directories if they don't exist
                    os.makedirs(os.path.dirname(file_path), exist_ok=True)
                    
                    # Save the file
                    file.save(file_path)
            
            # Create project record in database
            created_project = self.insert_project(project_name, participant_id, new_project_path)
            
            return {
                'project_id': created_project['project_id'],
                'participant_id': participant_id,
                'project_path': new_project_path,
                'files_processed': len([f for f in uploaded_files if f.filename and f.filename != ''])
            }
            
        except Exception as e:
            # Clean up on error
            if os.path.exists(new_project_path):
                shutil.rmtree(new_project_path)
            raise DatabaseError(f'Failed to create project with files: {str(e)}')

    def get_labelings(self, project_id=None):
        """Get labelings for a project, filtering out deleted ones by default"""
        import json
        
        labelings_data = self.project_repo.get_labelings(project_id)
        
        # If no labelings data, return as is
        if not labelings_data or not labelings_data[0].get('labelings'):
            return labelings_data
            
        # Filter out deleted labelings
        try:
            labelings = json.loads(labelings_data[0]['labelings'])
            if isinstance(labelings, list):
                # Filter out labelings marked as deleted
                active_labelings = []
                for labeling in labelings:
                    if isinstance(labeling, dict):
                        # Only include if not deleted
                        if not labeling.get('is_deleted', False):
                            active_labelings.append(labeling)
                    elif isinstance(labeling, str):
                        # String labelings are considered active (old format)
                        active_labelings.append(labeling)
                
                # Update the labelings data with filtered results
                labelings_data[0]['labelings'] = json.dumps(active_labelings)
                
        except (json.JSONDecodeError, TypeError, KeyError):
            # If there's an error parsing, return original data
            pass
            
        return labelings_data

    def update_labelings(self, project_id, label):
        """Update labelings for a specific project by appending a new label"""
        logger.info(f'Updating labelings for project {project_id} with label: {label}')
        return self.project_repo.update_labelings(project_id, label)
        
    def update_labeling_color(self, project_id, labeling_name, color):
        """Update the color of an existing labeling in a project
        
        Args:
            project_id: ID of the project containing the labeling
            labeling_name: Name of the labeling to update
            color: New color value in hex format (e.g., '#FF0000')
            
        Returns:
            dict: Status and message indicating success or failure
        """
        logger.info(f'Updating color for labeling "{labeling_name}" to {color} in project {project_id}')
        return self.project_repo.update_labeling_color(project_id, labeling_name, color)
        
    def rename_labeling(self, project_id, old_name, new_name):
        """Rename an existing labeling in a project
        
        Args:
            project_id: ID of the project containing the labeling
            old_name: Current name of the labeling
            new_name: New name for the labeling
            
        Returns:
            dict: Status and message indicating success or failure
        """
        logger.info(f'Renaming labeling from "{old_name}" to "{new_name}" in project {project_id}')
        return self.project_repo.rename_labeling(project_id, old_name, new_name)

    def delete_labeling(self, project_id, labeling_name):
        """Mark a labeling as deleted in a project
        
        Args:
            project_id: ID of the project containing the labeling
            labeling_name: Name of the labeling to delete
            
        Returns:
            dict: Status and message indicating success or failure
        """
        logger.info(f'Marking labeling "{labeling_name}" as deleted in project {project_id}')
        return self.project_repo.delete_labeling(project_id, labeling_name)

    def discover_project_sessions(self, project_path):
        """
        Discover session directories within a project path
        
        Args:
            project_path: Path to the project directory
            
        Returns:
            list: List of session dictionaries with name and file information, sorted by date
        """
        sessions = []
        if os.path.exists(project_path):
            for item in os.listdir(project_path):
                item_path = os.path.join(project_path, item)
                if os.path.isdir(item_path):
                    accel_file = os.path.join(item_path, 'accelerometer_data.csv')
                    if os.path.exists(accel_file):
                        sessions.append({'name': item, 'file': 'accelerometer_data.csv'})
                    elif os.path.exists(os.path.join(item_path, 'accelerometer_data.gz')):
                        # Unzip
                        gz_file = os.path.join(item_path, 'accelerometer_data.gz')
                        csv_file = os.path.join(item_path, 'accelerometer_data.csv')
                        # Use sed on macOS to remove last line, head on other systems
                        import platform
                        if platform.system() == 'Darwin':  # macOS
                            os.system(f'gunzip -c "{gz_file}" | sed \'$d\' > "{csv_file}"')
                        else:
                            os.system(f'gunzip -c "{gz_file}" | head -n -1 > "{csv_file}"')
                        sessions.append({'name': item, 'file': 'accelerometer_data.csv'})
                        os.remove(gz_file)
                    
                    gyro_data = os.path.join(item_path, 'gyroscope_data.csv')
                    gz_file = os.path.join(item_path, 'gyroscope_data.gz')

                    if os.path.exists(gyro_data):
                        logger.debug('Found gyroscope data:', gyro_data)
                    else:
                        logger.debug('No gyroscope data found in:', item_path)
                        if os.path.exists(gz_file):
                            # Use sed on macOS to remove last line, head on other systems
                            if platform.system() == 'Darwin':  # macOS
                                os.system(f'gunzip -c "{gz_file}" | sed \'$d\' > "{gyro_data}"')
                            else:
                                os.system(f'gunzip -c "{gz_file}" | head -n -1 > "{gyro_data}"')
                    if os.path.exists(gz_file):                         
                        os.remove(gz_file)
                        
            # Sort sessions by date/time in the name
            try:
                from datetime import datetime
                sessions.sort(key=lambda s: datetime.strptime('_'.join(s['name'].split('_')[:4]), '%Y-%m-%d_%H_%M_%S'))
            except:
                # If sorting fails, keep original order
                pass
        
        return sessions